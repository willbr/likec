(range)

for i in (range 10)
=> '(0 1 2 3 4 5 6 7 8 9)

for i in (range 1 10)
=> '(1 2 3 4 5 6 7 8 9)

for i in (range 0 10 2)
=> '(2 4 6 8)

;;;;

add list functions

map reduce filter

all some none
trues falses

remove odd '(1 2 3 4 5 6 7)
=> '(2 4 6)

keep odd '(1 2 3 4 5 6 7)
=> '(1 3 5 7)

;;;;

compose functions

odd:car '(1 2 3)

(odd (car '(1 2 3)))

;;;;

negate

odd 1
=> true

not (odd 1)
=> false

~odd 1
=> false

;;;;

Stack

push
pop

= a (Stack)
.push a 5
a.push 4
a push 3

;;;;

replace `for in list` with each

each (n int) (List 1 2 3 4)
    prn n

;;;;

while (isnt (= c (getchar)) EOF)
    if (== c '\n')
        inc nl
prn nl

=>

(while (isnt (= c (getchar)) EOF)
    (if (== c '\n')
        (inc nl)))
(prn nl)

;;;;

prn "hello"
=> puts("hello")
=> printf("hello\n")

pr "hello"
=> printf("hello")

;;;;

repeat 5
    prn "hello"

=>
hello
hello
hello
hello
hello

;;;;

copy clojurescript javascript method calls

= a (List)
.append a
:append a

or even?

a.append 5
a append 5

easier to type
having a dot makes it easier to know that a is an Object and not a
function

;;;;


use , to escape lexp calls

puts
    ,"hello world"

=>

(puts "hello world")

and not
(puts ("hello world")


;;;;

fix declare from moving rvalue of assignment to top with declare
new variables should initialise to defualt type values

;;;;


below is really templates

add macro map

def double (n int) int
    return (* n 2)

= a (List 1 2 3)
= b (map double a)

macro map (f (fn (any) any) old-list List) List
    = new-list (List)
    for (n (return-type f)) in old-list
        append (f n) to new-list
    return new-list

=>

def macro_map_1234 (f (fn (int) int) old-list List) List
    = new-list (List)
    for (n int) in old-list
        append (f n) to new-list
    return new-list

= a (List 1 2 3)
= b (macro_map_1234 double a)

=> or if it only has a single return value at the end

= a (List 1 2 3)
= macro__new-list1234 (List)
for (n int) in a
    append (double n) to macro__new-list1234
= b macro__new-list1234

;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;;
;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;;

add global variables

;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;;
;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;;

add SDL object

play with const

;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;;
;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;;

add Structs
not a pointer unlike objects
have one method; a constructor called new

struct Point
    x int
    y int

    def new (x int y int) Point
        @x = x
        @y = y
        return @


;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;;
;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;; ;;;;;

add strings as an object

change main definition
    def main (args List) int
        return 0

obj String
    length size_t
    data (* char)

    def new (s (* char))
        = @length (+ (strlen s) 1)
        = @data (malloc @length)
        strncpy @data s @length

    def die
        free @data

;;;;

auto insert die method into objects

;;;;

Add Stack

;;;;

Add Hash / Dict

;;;;

move for ? in ?
to
each ? in ?
or
each ? ?

;;;;

write more tests

;;;;

(in a b)

if a isn't a constant
eval a ONCE!

a_evaled = eval(a)

a_evaled == [b 0] || a_evaled [b 1]

;;;;

add CArray constructor

